*********************************************************************
REQUIREMENTS

Files compile with Coq v8.4. If your Coq binaries are not in the
default location (/usr/bin/ or /usr/local/bin/), you need to create a
file called "settings.sh" and set COQBIN to the appropriate path, e.g.:
COQBIN=/var/tmp/coq8.4/bin/

You also need subversion to get TLC (else you need to import the TLC
library by hand).

Finally, you need ocaml, ocamlfind (package ocaml-findlib) and
xml-light (package libxml-light-ocaml-dev) to compile the extracted
interpreter.

*********************************************************************
INSTALLATION AND COMPILATION

0) Get coq, ocaml >= 4.0, ocamlfind and xml-light. Most of the project
   devs seem to be using opam to manage this installs, which you can
   get from here:

   http://opam.ocamlpro.com/

   Then run "opam install coq ; opam install ocamlfind ; opam install xml-light"

1) Run "make init" to install the parser, TLC, and Flocq (requires subversion)

1') If you did not obtain the files through git (typically if you got
    a snapshot), you then need to fetch the parser manually:
    
    rmdir src/core/trunk/interp/parser
    git submodule add https://github.com/resource-reasoning/JS_Parser.git src/core/trunk/interp/parser

2) Run "make" to compile the files (ignore the warnings),
   Run "make -j 2" if your machine has two cores.

   The first time you do this it WILL FAIL. Run "make" a second time before worrying.

3) Run "./open.sh & " to edit files in CoqIDE

4) Run "make clean" to clean JS files,
   Run "make clean_all" to also clean in TLC and Flocq


*********************************************************************
TESTING OTHER PLATFORMS

We have a test harness that can run our tests (currenly mostly the
test262 ones) on JSRef, LambdaS5, SpiderMonkey and node.js. To test
JSRef, just do:

 $ make run_tests

To test SpiderMonkey, you will first have to install it. You can find
instructions here:

https://developer.mozilla.org/en-US/docs/SpiderMonkey/Build_Documentation

Be aware that the Central repo is quite big, and hg isn't good at
downloading large quantities of stuff. If you want to be bleeding
edge, you may be best off downloading an hg bundle, then pulling the
latest changes onto it. This is described here:

https://developer.mozilla.org/en/docs/Developer_Guide/Source_Code/Mercurial

Then, you'll need to edit settings.sh and add a line setting the
SPIDERMONKEY variable to point to your install. Finally, you can run

 $ make run_tests_spidermonkey

To test node.js, you'll need a node install. There are many ways to
get these, but a popular one is:

 $ sudo apt-get install nodejs

Then, you'll need to edit settings.sh and add a line setting the
NODEJS variable to point to your install. Finally, you can run

 $ make run_tests_nodejs

To test LambdaS5, you'll first need to install it. Follow their
instructions here:

https://github.com/brownplt/LambdaS5             

Then, you'll need to edit settings.sh and add a line setting the
LAMBDAS5 variable to point to your install. Finally, you can run

 $ make run_tests_lambdaS5

*********************************************************************
GENERATING TEST REPORTS

If you want to generate a pretty web page that presents all the
results of the test run, you'll first need to install pystache:

 $ pip install --user pystache
 $ pystache-test

Now you can run

 $ ./runtests.py --webreport

This will run exactly the same tests as the makefile, but it will also
generate a new results page in the web directory of the repo, and add
this page to the web index. You can see all the reports we have
generated so far by browsing to jscert/web/test_results/index.html

Try running:

 $ ./runtests.py --help

to see what options are available. Notice in particular that you can
choose to run only a subset of the available tests, give this testrun
a title, and add a note explaining why that subset is interesting.

For example, you may wish to run only the tests in the "more_tests"
directory:

 $ ./runtests.py --webreport --title more-tests --note "These 'more-tests' show up a fascinating behaviour!" tests/more-tests/*.js

*********************************************************************
USING THE CERTIFIED INTERPRETER		(* TODO:  Update *)

The interpreter is defined and proven in the file “JsInterpreter.v” by
the functions “run_expr”, “run_stat” and “run_prog” (and the theorems
“run_expr_correct”, “run_stat_correct” and “run_prog_correct”). As
every function must terminate in Coq, its first argument is the
maximum number of step the computation has to last.  This function
returns one of the three following output:
- out_bottom, when the computation lasts longer than the "max_step" argument.
- out_unspec, when the output result is unspecified.
- out_return h r, when the computation ran without problem,
  returning the heap state h and the result r.
  Note that the result may be an error.

There is a boolean parameter “Mnostuck” stating what should be done
when no reduction rule in “red_expr”, “red_stat” or “red_prog” can be
applied.  If it is set to true, then it returns an error, otherwise it
stops and returns “out_unspec”.

Examples of code generation are given in the file “JsInterpreterExample.v”.

The first step is to define a Javascript program using the grammar of JsDefs.
See the definition of the objects “prog1” and “prog2”. The “seq” construction
just constructs a tree of “exp_seq” with its arguments list. Then you have to
define its run (it is the definition of “computation1” and “computation2”),
 in the initial heap and the default scope [loc_global ; loc_scope].

Once you have defined it, you can extract it with the line
"Extraction "js/interpreter.ml" fresh_for_list <your computation>."
Note that "fresh_for_list" have to be extracted too.
This will create a file "interpreter.ml" which contains the ocaml source code.
To compile it, you can use the "make interpreter" command.
The executable won't output anything though, so you should use the interpreter
"ocaml" to see the result.

Type "#use "interpreter.ml";;" to load the interpreter code, including
 the result of the computation.  The result may be too complex to be displayed,
so you can need the following commands to see it:
    #print_length 10_000;;
    computation2;;
If you want to make sense of the heap, you need to use another small tool:
   #use "../tools/prheap.ml";;
   main computation2;;
This will dump some text that you can copy and paste in a dot file,
which you can look with tools like graphviz.
At the top of each cell is the location.  If there is a "null" in the bottom left,
 it means the prototype is loc_null, and if there is an "obj_pr"
the prototype is "obj_proto" (this gather many common cases).
At the bottom right is the common this field (glob for loc_global).
Scopes are written as list of locations, as in "8 | global | scope".

