
========== Global object ===============

global heap:
   prealloc_global --> object_prealloc_global

object_prealloc_global
   .properties_:
      "Number" --> prealloc_number


========== Object Number ===============

global heap:
   prealloc_number --> object_prealloc_number

object_prealloc_number:
   .class_ := "Function"
   .proto_ := prealloc_function_proto
   .construct_ := (construct_prealloc prealloc_number)
   .properties_ :
      "NaN" --> JsNumber.nan
      "prototype" --> prealloc_number_proto


========== Class Number.prototype ===============

global heap:
   prealloc_number_proto --> object_prealloc_number_proto

object_prealloc_number_proto:
   .value_ := JsNumbe.zero
   .proto_ := prealloc_object_proto
   .class_ := "Number"
   .properties_ :=
      "toString" --> prealloc_number_proto_to_string
      "constructor" --> prealloc_number


========== Method toString from Number.prototype ===============

object_prealloc_number_proto.properties_:
   "toString" --> prealloc_number_proto_to_string

global heap:
   prealloc_number_proto_to_string --> number_proto_to_string_function_object

number_proto_to_string_function_object:
   .proto_ := prealloc_function_proto
   .class_ := "Function" 
   .properties_ := "length" --> (attrib_constant 0) 
   .call_:= Some (call_prealloc prealloc_number_proto_to_string)

red_spec_call_number_proto_to_string:
   ... -> red_expr S C (spec_call_prealloc prealloc_number_proto_to_string args) o


========== Constructor method of Number ===============

The "new Number(args)" syntax gives rise to "spec_construct".

  | red_spec_constructor : forall S C l B args o,
      object_method object_construct_ S l (Some B) ->
      red_expr S C (spec_construct_1 B l args) o ->
      red_expr S C (spec_construct l args) o

In the "construct_" field, we find a "construct_prealloc".

  | red_spec_construct_1_prealloc : forall S C B l args o,
      red_expr S C (spec_construct_prealloc B args) o -> 
      red_expr S C (spec_construct_1 (construct_prealloc B) l args) o   

The reductions rule for "spec_construct_prealloc prealloc_number" lead to:

   ...
   let O1 := object_new prealloc_number_proto "Number" in
   let O := object_with_primitive_value O1 v in 
   (l, S') = object_alloc S O ->
   red_expr S C (spec_construct_prealloc prealloc_number args) (out_ter S' l) 

The latter allocates a new object of class "Number" with prototype "prealloc_number_proto"


========== Calls to Number() without new ===============

If we write "Number()" without new, we get a call:

  | red_spec_call_1_prealloc : forall S C B lo this args o,
      red_expr S C (spec_call_prealloc B args) o -> 
      red_expr S C (spec_call_1 (call_prealloc B) lo this args) o
 
In the "call_" field, we find a "construct_prealloc".

  | red_spec_call_1_prealloc : forall S C B lo this args o,
      red_expr S C (spec_call_prealloc B args) o -> 
      red_expr S C (spec_call_1 (call_prealloc B) lo this args) o

The reductions rule for "spec_call_prealloc prealloc_number" lead to:

  | red_spec_call_number_nil : forall S C, 
      red_expr S C (spec_call_prealloc prealloc_number nil) (out_ter S JsNumber.zero) 

  | red_spec_call_number_not_nil : forall S C v o args,
      args <> nil ->
      arguments_from args (v::nil) ->
      red_expr S C (spec_to_number v) o ->
      red_expr S C (spec_call_prealloc prealloc_number args) o 

The latter rules directly return a value, without allocating an object.





---------
---------
---------
---------
---------
---------
---------
---------


x = { a: 1 }
y = { b: 2 }
y.__proto___ = x
z = { c: 3 }
z.__proto___ = y

(function demo()) {
	count = 0
	for (k in z) {
		if (count++ == 0)
			z.___proto___ = x
		if (k == "a")
			return 1
	}
	return 0 })()
   
---------
 
   TODO: we need to check whether the rules handle correctly the
  behaviors with an empty res_value. (they should use rv instead of v to propagate)

---------

(* SameValue: TODO: problem of the several representations of NaN *)

(* File JsPreliminary: Martin: move what you don't use in the interpreter
   from section "Factorization of rules for binary operators"
   into JsPrettyInterm. *)

TODO: discuter de :
   Axiom parse_pickable : forall s, Pickable (parse s).

TODO: discuter des boucles

TODO: remove preallocated errors 

Le makefile ne fait pas  
   mkdir -p interp/src/extract
du coup error sur coqdep 


TODO: abort_intercepted check whether we need to add this:

comprend pas:
      (* [stat_try_3] is marked as intercepting [abort] rules in [abort_intercepted_stat]:  does that mean that there actually is a way not to execute the [finally] part of a [try/catch/finally] while actually executing a part of the [try] block?  -- Martin. *)

attributes_writable (* TODO: check:  Even if it's used in the semantics, is that wanted? -- Martin *)


  (** ** Conversions (9) *)
  (* TODO:  spec_to_primitive_auto *)
  (* TODO:  spec_prim_new_object *)


=======
=======
=======


ARTHUR:
* Changed semantics of loop to better match paper
* 12.6.2 seems boggus: if continue, then even if not good label, will loop




=======
TODO


(** ---TODO :  Entering eval code (10.4.2) *)    

*) Inductive funccode => deprecated?

*) resolve ambiguity "propname" vs "prop_name"


===
ONCE INTERPRETER IS STABILIZED

*) Factorization of rules for binary operators : move a bunch of these defs into js_pretty_inter 


=====
LESS URGENT

*) stat_vardecl : stat_for_in_var 

*) factorize syntax of for_in and for_in_var 

*) Find an order for sections in JsPreliminary

*) TODO: store the fresh locations into a wrapper around LibHeap

*) we would be closer to the spec in red_stat_try_1_catch_throw
   if lexical environments were not lists, but instead objects with a parent field,
   however this would come at the cost of having a predicate to enforce acyclicity

*) a generic rule for obtaining arguments

=====
INVARIANT ON SYNTAX

- "try" must have either catch or finally
- "with" statement cannot be in strict mode

-- a result triple, if is of type throw, carries a real value (not empty nor reference)



=====
INVARIANT ON WF

  | red_expr_delete_1_ref_unresolvable : forall S0 S C r o,
      ref_is_unresolvable r ->
      red_expr S C (spec_error_or_cst (ref_strict r) builtin_syntax_error true) o -> 
      red_expr S0 C (expr_delete_1 (out_ter S (ret_ref r))) o

  | red_expr_delete_3_strict : forall S C r L o,
      red_expr S C (spec_error builtin_syntax_error) o -> 
      red_expr S C (expr_delete_3 r L true) o 

  | red_expr_prepost_1_invalid : forall S0 S C op R,
      ~ valid_lhs_for_assign R ->
      red_expr S0 C (expr_prepost_1 op (out_ter S R)) (out_syntax_error S)

  | red_expr_prepost_1_valid : forall S0 S C R op o1 o,
      valid_lhs_for_assign R ->

=====
BUG:

x: { try { throw 1 } catch (e) { break x } finally { 2 } }
2
x: { try { throw 1 } catch (e) { break x } finally { } }
undefined
x: { try { throw 1 } catch (e) { 3; break x } finally { } }
3

function f() {x: { try { throw 1 } catch (e) { return 3 } finally { 2 } } }; f()
3
function f() {x: { try { throw 1 } catch (e) { return 3 } finally { return 2 } } }; f()
2
function f() {x: { try { throw 1 } catch (e) { return 3 } finally { break x } }; return 2 }; f()
2

function f() {  try { return 1 } finally { return 2 } }; f()
2
function f() {  x : { try { return 1 } finally { break x } }; return 4 }; f()
4
function f() {  x : { try { return 1 } finally {  } }; return 4 }; f()
1
function f() {  x : { try { break x } finally { 2 } }; return 4 }; f()
4
function f() {  x : { try { break x } finally { 2 } ; return 3 }; return 4 }; f()
4
function f() {  y: { x : { try { break x } catch (e) { break y } finally { 2 } ; return 3 }; return 4 } ; return 5 }; f()
4

=====
TEST:

delete {}




(** [valid_lhs_for_assign R] asserts that [R] will not satisfy
    the condition under which a SyntaxError gets triggered
    (see the semantics of simple assignement in the spec).
    LATER: will be used if we do not rely on parser for raising
    the SyntaxError. *)

Open Scope string_scope. (* TODO: move to top of the file *)

(* LATER: only for syntax errors
Definition valid_lhs_for_assign R :=
  ~ (exists r,
         R = ret_ref r
      /\ ref_strict r = true
      /\ ref_kind_of r = ref_kind_env_record
      /\ let s := ref_name r in
         (s = "eval" \/ s = "arguments")).
*)




(**************************************************************)
(** ** Read and updates on descriptors *)

(** Assumes fully-populated in the sense of 

Definition descriptor_is_writable Desc :=
  match Ad with descriptor_intro ov ow og os oe oc =>
                descriptor_intro ov (Some false) og os oe oc end.

Definition descriptor_is_configurable Desc :=
  match Ad with descriptor_intro ov ow og os oe oc =>
                descriptor_intro ov (Some false) og os oe oc end.


Definition descriptor_with_writable_false Desc :=
  match Ad with descriptor_intro ov ow og os oe oc =>
                descriptor_intro ov (Some false) og os oe oc end.

Definition descriptor_with_configurable_false Desc :=
  match Ad with descriptor_intro ov ow og os oe oc =>
                descriptor_intro ov ow og os oe (Some false) end.
