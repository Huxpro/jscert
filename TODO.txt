
=======
TODO


(** ---TODO :  Entering eval code (10.4.2) *)    

*) Inductive funccode => deprecated?

*) resolve ambiguity "propname" vs "prop_name"


===
ONCE INTERPRETER IS STABILIZED

*) Factorization of rules for binary operators : move a bunch of these defs into js_pretty_inter 


=====
LESS URGENT

*) stat_vardecl : stat_for_in_var 

*) factorize syntax of for_in and for_in_var 

*) Find an order for sections in JsPreliminary

*) TODO: store the fresh locations into a wrapper around LibHeap

*) we would be closer to the spec in red_stat_try_1_catch_throw
   if lexical environments were not lists, but instead objects with a parent field,
   however this would come at the cost of having a predicate to enforce acyclicity

*) a generic rule for obtaining arguments

=====
INVARIANT ON SYNTAX

- "try" must have either catch or finally
- "with" statement cannot be in strict mode

-- a result triple, if is of type throw, carries a real value (not empty nor reference)



=====
INVARIANT ON WF

  | red_expr_delete_1_ref_unresolvable : forall S0 S C r o,
      ref_is_unresolvable r ->
      red_expr S C (spec_error_or_cst (ref_strict r) builtin_syntax_error true) o -> 
      red_expr S0 C (expr_delete_1 (out_ter S (ret_ref r))) o

  | red_expr_delete_3_strict : forall S C r L o,
      red_expr S C (spec_error builtin_syntax_error) o -> 
      red_expr S C (expr_delete_3 r L true) o 

  | red_expr_prepost_1_invalid : forall S0 S C op R,
      ~ valid_lhs_for_assign R ->
      red_expr S0 C (expr_prepost_1 op (out_ter S R)) (out_syntax_error S)

  | red_expr_prepost_1_valid : forall S0 S C R op o1 o,
      valid_lhs_for_assign R ->

=====
BUG:

x: { try { throw 1 } catch (e) { break x } finally { 2 } }
2
x: { try { throw 1 } catch (e) { break x } finally { } }
undefined
x: { try { throw 1 } catch (e) { 3; break x } finally { } }
3

function f() {x: { try { throw 1 } catch (e) { return 3 } finally { 2 } } }; f()
3
function f() {x: { try { throw 1 } catch (e) { return 3 } finally { return 2 } } }; f()
2
function f() {x: { try { throw 1 } catch (e) { return 3 } finally { break x } }; return 2 }; f()
2

function f() {  try { return 1 } finally { return 2 } }; f()
2
function f() {  x : { try { return 1 } finally { break x } }; return 4 }; f()
4
function f() {  x : { try { return 1 } finally {  } }; return 4 }; f()
1
function f() {  x : { try { break x } finally { 2 } }; return 4 }; f()
4
function f() {  x : { try { break x } finally { 2 } ; return 3 }; return 4 }; f()
4
function f() {  y: { x : { try { break x } catch (e) { break y } finally { 2 } ; return 3 }; return 4 } ; return 5 }; f()
4

=====
TEST:

delete {}
