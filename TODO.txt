

Inductive restype :=
  | restype_normal
  | restype_break
  | restype_continue
  | restype_return
  | restype_throw.

Inductive resvalue :=
  | resvalue_empty : resvalue
  | resvalue_value : value -> resvalue
  | resvalue_ref : ref -> resvalue.

Definition res := (restype * resvalue * label_opt)%type.

(** Projection for [res] *)

Definition res_type_of R :=
  match R with (rt, _, _) => rt end.

Definition res_value_of R :=
  match R with (_, rv, _) => rv end.

Definition res_label_of R :=
  match R with (_, _, labopt) => labopt end.

(** Modification of fields for type [res] *)

Definition res_with_type R rt :=
  match R with (old_rt, rv, lo) => (rt, rv, lo) end.

Definition res_with_value R rv :=
  match R with (rt, old_rv, lo) => (rt, rv, lo) end.

(** Smart constructors for type [res] *)

Coercion res_ref r := (restype_normal, resvalue_ref r, None).
Coercion res_value v := (restype_normal, resvalue_value v, None).
Definition res_empty := (restype_normal, resvalue_empty, None).
Definition res_break labopt := (restype_break, resvalue_empty, labopt).
Definition res_continue labopt := (restype_continue, resvalue_empty, labopt).
Definition res_return v := (restype_return, resvalue_value v, None).
Definition res_throw v := (restype_throw, resvalue_value v, None).

(** Test whether [res] has an empty value *)

Definition res_value_is_empty R :=
  res_get_value R = resvalue_empty.

(** Update the value field if it is empty *)

Definition res_overwrite_value_if_empty Rold Rnew :=
  If res_get_value Rnew = resvalue_empty 
    then res_with_value Rnew (res_value_of Rold)
    else Rnew.





Martin: I changed & moved the definition of execution_ctx_initial, see JsPreliminary

=======

*) add label sets on blocks
*) handle break on stat_label

*) is function_code deprecated

*) factorize syntax of for_in and for_in_var 

*) prog_function_decl : should it be removed since nonstandard?

*) Inductive funccode => deprecated?

*) Definition of the "SameValue" algorithm -- TODO: does not seem to be used 

*) Define [abort] as "not a normal behavior",
   by taking the negation of being of the form [ter (normal ...)]. *)

*) delete section for errors, since it was already moved to jsprettyinterm

*) resolve ambiguity "propname" vs "prop_name"

*) Factorization of rules for binary operators : move a bunch of these defs into js_pretty_inter 

*) stat_vardecl : stat_for_in_var 

*)  initialize the execution context with binding instantiation 

(* TODO: handle labels in while loops *)

=====
LESS URGENT

*) Find an order for sections in JsPreliminary

*) TODO: store the fresh locations into a wrapper around LibHeap

*) we would be closer to the spec in red_stat_try_1_catch_throw
   if lexical environments were not lists, but instead objects with a parent field,
   however this would come at the cost of having a predicate to enforce acyclicity


=====
INVARIANT ON SYNTAX

- "try" must have either catch or finally
- "with" statement cannot be in strict mode




=====
INVARIANT ON WF

  | red_expr_delete_1_ref_unresolvable : forall S0 S C r o,
      ref_is_unresolvable r ->
      red_expr S C (spec_error_or_cst (ref_strict r) builtin_syntax_error true) o -> 
      red_expr S0 C (expr_delete_1 (out_ter S (ret_ref r))) o

  | red_expr_delete_3_strict : forall S C r L o,
      red_expr S C (spec_error builtin_syntax_error) o -> 
      red_expr S C (expr_delete_3 r L true) o 

  | red_expr_prepost_1_invalid : forall S0 S C op R,
      ~ valid_lhs_for_assign R ->
      red_expr S0 C (expr_prepost_1 op (out_ter S R)) (out_syntax_error S)

  | red_expr_prepost_1_valid : forall S0 S C R op o1 o,
      valid_lhs_for_assign R ->
