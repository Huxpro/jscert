      O = object_new builtin_object_proto "Object" true -> (* TODO fix this *)




(*---start todo---*)


- object_get
- define own property
(* TODO: spec_object_get_using is like spec_object_get except that the this value is different *)
(** Special Put method for primitive values : TODO *)
- section 10.4



-----



Martin: I changed & moved the definition of execution_ctx_initial, see JsPreliminary

=======

*) add label sets on blocks
*) handle break on stat_label

*) is function_code deprecated

*) factorize syntax of for_in and for_in_var 

*) prog_function_decl : should it be removed since nonstandard?

*) Inductive funccode => deprecated?

*) Definition of the "SameValue" algorithm -- TODO: does not seem to be used 

*) Define [abort] as "not a normal behavior",
   by taking the negation of being of the form [ter (normal ...)]. *)

*) delete section for errors, since it was already moved to jsprettyinterm

*) resolve ambiguity "propname" vs "prop_name"

*) Factorization of rules for binary operators : move a bunch of these defs into js_pretty_inter 

*) stat_vardecl : stat_for_in_var 

*)  initialize the execution context with binding instantiation 

(* TODO: handle labels in while loops *)

(* TODO: abort_intercepted check whether we need to add this:




=====
LESS URGENT

*) Find an order for sections in JsPreliminary

*) TODO: store the fresh locations into a wrapper around LibHeap

*) we would be closer to the spec in red_stat_try_1_catch_throw
   if lexical environments were not lists, but instead objects with a parent field,
   however this would come at the cost of having a predicate to enforce acyclicity

*) a generic rule for obtaining arguments

=====
INVARIANT ON SYNTAX

- "try" must have either catch or finally
- "with" statement cannot be in strict mode




=====
INVARIANT ON WF

  | red_expr_delete_1_ref_unresolvable : forall S0 S C r o,
      ref_is_unresolvable r ->
      red_expr S C (spec_error_or_cst (ref_strict r) builtin_syntax_error true) o -> 
      red_expr S0 C (expr_delete_1 (out_ter S (ret_ref r))) o

  | red_expr_delete_3_strict : forall S C r L o,
      red_expr S C (spec_error builtin_syntax_error) o -> 
      red_expr S C (expr_delete_3 r L true) o 

  | red_expr_prepost_1_invalid : forall S0 S C op R,
      ~ valid_lhs_for_assign R ->
      red_expr S0 C (expr_prepost_1 op (out_ter S R)) (out_syntax_error S)

  | red_expr_prepost_1_valid : forall S0 S C R op o1 o,
      valid_lhs_for_assign R ->

=====
BUG:

x: { try { throw 1 } catch (e) { break x } finally { 2 } }
2
x: { try { throw 1 } catch (e) { break x } finally { } }
undefined
x: { try { throw 1 } catch (e) { 3; break x } finally { } }
3

function f() {x: { try { throw 1 } catch (e) { return 3 } finally { 2 } } }; f()
3
function f() {x: { try { throw 1 } catch (e) { return 3 } finally { return 2 } } }; f()
2
function f() {x: { try { throw 1 } catch (e) { return 3 } finally { break x } }; return 2 }; f()
2

function f() {  try { return 1 } finally { return 2 } }; f()
2
function f() {  x : { try { return 1 } finally { break x } }; return 4 }; f()
4
function f() {  x : { try { return 1 } finally {  } }; return 4 }; f()
1
function f() {  x : { try { break x } finally { 2 } }; return 4 }; f()
4
function f() {  x : { try { break x } finally { 2 } ; return 3 }; return 4 }; f()
4
function f() {  y: { x : { try { break x } catch (e) { break y } finally { 2 } ; return 3 }; return 4 } ; return 5 }; f()
4

=====
TEST:

delete {}